---
layout: post
title:  "Leetcode1: Two Sum"
date:   2024-06-13 20:46:40 +0000
categories: leetcode hash_table
---

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.

<h2>Brute Force</h2>
The straightforward way is double-looping. For each number, iterate all other numbers,
if those 2 add up to the target number. Return their indexes.<br>
Time complexity: O(N^2)

<h2>Sorting</h2>
Sorting the input array can help. After sorting, we can use two pointers approach. That one pointer at
the head and the other at the end, moving those 2 pointers towards the middle until we find a solution.
Extra work is needed to find the index of the number. The sorting won't keep the number indexes.
Time complexity: O(N*log(N))

<h2>Hash Table</h2>
Having a first round of iteration of those numbers, keep track of the mapping from number to its index.
As each input just have <b>exactly one solution</b>. It is okay to overwrite the index if there are 
duplicates. Because the second round of iteration will start from beginning, and if the solution are
composed of two duplicates number, the iterator is at the first duplicate while the hashmap returns the
last duplicate.<br>
Time complexity: O(N) <br>
Space complexity: O(N) <br>

<h2> Java Code </h2>
<pre>
<code>
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // First round of iteration to create mapping from num to index.
        Map<Integer, Integer> numToIndex = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            numToIndex.put(nums[i], i);
        }
        // Second round of iteration to find the pair of (num, target-num)
        for (int i = 0; i < nums.length; ++i) {
            Integer j = numToIndex.get(target - nums[i]);
            if (j == null || i == j) continue;
            return new int[]{i, j};
        }
        return null;
    }
}
</code>
</pre>


You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run `jekyll serve`, which launches a web server and auto-regenerates your site when a file is updated.

Jekyll requires blog post files to be named according to the following format:

`YEAR-MONTH-DAY-title.MARKUP`

Where `YEAR` is a four-digit number, `MONTH` and `DAY` are both two-digit numbers, and `MARKUP` is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.

Jekyll also offers powerful support for code snippets:

{% highlight ruby %}
def print_hi(name)
  puts "Hi, #{name}"
end
print_hi('Tom')
#=> prints 'Hi, Tom' to STDOUT.
{% endhighlight %}

Check out the [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
